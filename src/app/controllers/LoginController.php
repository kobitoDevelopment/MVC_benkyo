<?php
/**
 * =================================================================
 * LoginController - 認証機能を担当するコントローラークラス
 * =================================================================
 * 
 * 【役割と責任】
 * このコントローラーはWebアプリケーションの認証機能全般を担当します：
 * 1. ログイン画面の表示
 * 2. 認証処理（ユーザー名とパスワードの検証）
 * 3. セッション管理（ログイン状態の維持）
 * 4. ログアウト処理（セッション破棄）
 * 5. セキュリティ対策（CSRF、セッションハイジャック対策等）
 * 
 * 【セキュリティ設計の重要性】
 * 認証機能はWebアプリケーションの要となる部分であり、
 * 以下のセキュリティ脅威に対する防御策を実装しています：
 * - CSRF攻撃（Cross-Site Request Forgery）
 * - セッションハイジャック攻撃
 * - セッション固定化攻撃
 * - ブルートフォース攻撃
 * - 情報漏洩（パスワード等の機密情報）
 */

// 依存クラスの読み込み
// 本来はオートローダー（Composer）で自動化されるべきですが、
// 学習目的として明示的に記述しています
require_once __DIR__ . '/../core/BaseController.php';
require_once __DIR__ . '/../models/User.php';
require_once __DIR__ . '/../helpers/CsrfHelper.php';
require_once __DIR__ . '/../helpers/Validator.php';

use App\Core\BaseController;
use App\Models\User;

/**
 * ログイン機能コントローラー
 * 
 * 【継承構造】
 * BaseController（共通機能）
 *    ↑
 * LoginController（認証専用機能）
 * 
 * 【処理フロー】
 * 1. GET /login → index() → ログイン画面表示
 * 2. POST /login/authenticate → authenticate() → 認証処理
 * 3. POST /login/logout → logout() → ログアウト処理
 */
class LoginController extends BaseController
{
    /**
     * Userモデルのインスタンス
     * 
     * 【依存性注入の原則】
     * 理想的にはコンストラクタでUserモデルを注入すべきですが、
     * 学習用として簡潔な実装を採用しています
     */
    private $userModel;
    
    /**
     * コンストラクタ - 依存オブジェクトの初期化
     * 
     * 【初期化処理】
     * 認証処理で必要となるUserモデルのインスタンスを生成
     * これによりデータベースアクセス機能を利用可能にします
     */
    public function __construct()
    {
        $this->userModel = new User();
    }
    
    /**
     * ログイン画面の表示（GET /login）
     * 
     * 【二重ログイン防止機能】
     * 既にログイン済みのユーザーが再度ログインページにアクセスした場合、
     * 自動的にマイページへリダイレクトします。
     * これによりユーザビリティと一貫性を向上させます。
     * 
     * 【初期状態の設定】
     * - ページタイトルの設定
     * - エラーメッセージの初期化
     * - CSRFトークンの自動生成（BaseController::render()で実行）
     */
    public function index()
    {
        // ============================================================
        // 認証状態のチェック - 二重ログイン防止
        // ============================================================
        // isLoggedIn()はBaseControllerで定義されたメソッド
        // セッション変数 $_SESSION['user_id'] の存在をチェック
        if ($this->isLoggedIn()) {
            $this->redirect('/mypage');
        }
        
        // ============================================================
        // ビューに渡すデータの準備
        // ============================================================
        $data = [
            'title' => 'ログイン',          // HTMLのタイトルタグで使用
            'error' => ''                  // エラーメッセージ（初期は空文字）
        ];
        
        // ============================================================
        // ビューの描画
        // ============================================================
        // render()メソッドで以下の処理が自動実行されます：
        // 1. XSS対策のためのデータエスケープ
        // 2. CSRFトークンの自動生成・埋め込み
        // 3. レイアウトファイルの適用
        $this->render('login/index', $data);
    }
    
    /**
     * ログイン認証処理（POST /login/authenticate）
     * 
     * 【多層防御のセキュリティアーキテクチャ】
     * このメソッドは以下の段階的なセキュリティチェックを実装します：
     * 1. HTTPメソッド検証（POST以外を拒否）
     * 2. CSRF攻撃対策（トークン検証）
     * 3. 入力値検証（バリデーション）
     * 4. 認証処理（パスワード検証）
     * 5. セッション管理（ハイジャック対策）
     * 
     * 【認証フローの設計思想】
     * - Fail Fast: 不正なリクエストは早期段階で拒否
     * - 最小権限の原則: 必要最小限の情報のみ公開
     * - 攻撃者への情報漏洩防止: エラーメッセージの統一
     */
    public function authenticate()
    {
        // ============================================================
        // 1. HTTPメソッド検証
        // ============================================================
        // GET、PUT、DELETEなど、POST以外のメソッドでの不正アクセスを防ぐ
        // これによりブラウザのアドレスバーからの直接アクセスを阻止
        if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
            $this->redirect('/login');
        }
        
        // ============================================================
        // 2. CSRF攻撃対策 - トークン検証
        // ============================================================
        // verifyCsrfToken()はBaseControllerで実装されたメソッド
        // セッションに保存されたトークンとPOSTデータのトークンを比較
        if (!$this->verifyCsrfToken()) {
            $this->render('login/index', [
                'title' => 'ログイン',
                'error' => 'セキュリティエラーが発生しました。再度お試しください。'
            ]);
            return;
        }
        
        // ============================================================
        // 3. 入力値検証 - バリデーション処理
        // ============================================================
        // Validatorクラスでメソッドチェーンによる流麗なバリデーション
        // 各ルールが段階的に評価され、最初のエラーで停止します
        $validator = $this->validator()
            ->required('username', 'ユーザー名を入力してください。')
            ->required('password', 'パスワードを入力してください。')
            ->minLength('username', 3, 'ユーザー名は3文字以上で入力してください。')
            ->minLength('password', 6, 'パスワードは6文字以上で入力してください。');
        
        // バリデーション結果の評価とエラーハンドリング
        if (!$validator->isValid()) {
            $this->render('login/index', [
                'title' => 'ログイン',
                'error' => $validator->getFirstError(),
                'old_input' => $_POST // UXの向上：入力値を保持してユーザーの再入力負荷を軽減
            ]);
            return;
        }
        
        // ============================================================
        // 4. 認証情報の取得と前処理
        // ============================================================
        $username = $_POST['username'];
        $password = $_POST['password'];
        
        // ============================================================
        // 5. ユーザー認証 - データベース照合
        // ============================================================
        // Userモデルを使用してユーザー名からレコードを検索
        $user = $this->userModel->findByUsername($username);
        
        // パスワード検証とログイン成功時の処理
        if ($user && password_verify($password, $user['password'])) {
            
            // ============================================================
            // ログイン成功 - セッション管理の開始
            // ============================================================
            $this->startSession();
            
            // ============================================================
            // セッションハイジャック対策 - セッションID再生成
            // ============================================================
            // session_regenerate_id(true) で古いセッションファイルを削除
            // これにより、セッション固定化攻撃を防ぎます
            session_regenerate_id(true);
            
            // ============================================================
            // セッション変数の設定
            // ============================================================
            $_SESSION['user_id'] = $user['id'];           // 認証状態の判定に使用
            $_SESSION['username'] = $user['username'];     // 表示用
            $_SESSION['login_time'] = time();              // ログイン時刻（監査ログ用）
            
            // ============================================================
            // セッション情報のデータベース記録
            // ============================================================
            // セッションIDとユーザーIDの関連付けをデータベースに保存
            // これにより以下が実現されます：
            // - 複数端末での同時ログイン管理
            // - 不正アクセスの追跡
            // - セッションの強制無効化機能
            $this->userModel->createSession($user['id'], session_id());
            
            // ============================================================
            // 認証成功後のリダイレクト
            // ============================================================
            // PRG（Post-Redirect-Get）パターンの実装
            // ブラウザの戻るボタンでフォーム再送信を防ぐ
            $this->redirect('/mypage');
            
        } else {
            
            // ============================================================
            // ログイン失敗 - セキュリティ考慮したエラー処理
            // ============================================================
            // 【重要なセキュリティ設計】
            // 「ユーザーが存在しない」「パスワードが間違い」を区別せず
            // 統一したエラーメッセージを返すことで、ユーザー名の
            // 存在確認攻撃（Username Enumeration Attack）を防ぎます
            
            $this->render('login/index', [
                'title' => 'ログイン',
                'error' => 'ユーザー名またはパスワードが正しくありません。',
                
                // セキュリティ上の配慮：パスワードは保持しない
                // パスワードフィールドは常に空にして情報漏洩を防ぐ
                'old_input' => ['username' => $username] // ユーザー名のみ保持
            ]);
        }
    }
    
    /**
     * ログアウト処理（POST /login/logout）
     * 
     * 【安全なログアウトの3段階処理】
     * セキュリティを確保するため、以下の順序で処理を実行します：
     * 1. データベースからのセッション情報削除
     * 2. PHPセッション変数のクリア
     * 3. セッションファイルの完全破棄
     * 
     * 【なぜ段階的な処理が必要か】
     * - データベース削除失敗時でもローカルセッションは無効化される
     * - 第三者がセッションIDを取得していても再利用を防げる
     * - クライアント・サーバー両方でのセッション状態の確実な消去
     */
    public function logout()
    {
        // ============================================================
        // セッションの開始と有効性確認
        // ============================================================
        $this->startSession();
        
        // ============================================================
        // 1. データベースからのセッション情報削除
        // ============================================================
        // ユーザーがログイン済みの場合のみデータベース操作を実行
        // これにより不要なDBクエリを避けつつ、確実にセッション情報を削除
        if (isset($_SESSION['user_id'])) {
            // Userモデルを使用してsessionsテーブルからレコードを削除
            // これにより他の端末で同じセッションIDが使用されることを防ぎます
            $this->userModel->deleteSession(session_id());
        }
        
        // ============================================================
        // 2. セッション変数の完全クリア
        // ============================================================
        // $_SESSION配列を空配列で上書きすることで
        // 全てのセッション変数（user_id、username、login_time等）を削除
        $_SESSION = [];
        
        // ============================================================
        // 3. セッションの完全破棄
        // ============================================================
        // session_destroy()でサーバー上のセッションファイルを削除
        // これによりセッションIDが無効化され、再利用が不可能になります
        session_destroy();
        
        // ============================================================
        // ログアウト後のリダイレクト
        // ============================================================
        // トップページへリダイレクトして処理完了を明確化
        // PRGパターンによりブラウザの戻るボタンでの意図しない再実行を防止
        $this->redirect('/');
    }
}

/**
 * =================================================================
 * 【学習ポイント】認証システムの設計原則とセキュリティ対策
 * =================================================================
 * 
 * 1. 【多層防御（Defense in Depth）】
 *    - HTTPメソッド制限
 *    - CSRF攻撃対策
 *    - 入力値検証
 *    - セッション管理
 *    - データベース監査
 * 
 * 2. 【セキュアコーディング原則】
 *    - Fail Fast: 早期エラー検出と拒否
 *    - 最小権限の原則: 必要最小限の情報開示
 *    - 情報漏洩防止: 統一エラーメッセージ
 *    - 攻撃面の最小化: 不要な機能の削除
 * 
 * 3. 【セッション管理のベストプラクティス】
 *    - セッションID再生成による固定化攻撃対策
 *    - データベース連携による集中管理
 *    - 適切なタイムアウト設定
 *    - ログアウト時の完全クリーンアップ
 * 
 * 4. 【UX（ユーザーエクスペリエンス）配慮】
 *    - 入力値の保持によるユーザビリティ向上
 *    - わかりやすいエラーメッセージ
 *    - 二重ログイン防止による一貫性
 *    - PRGパターンによる操作の明確化
 * 
 * 5. 【拡張性とメンテナンス性】
 *    - BaseControllerによる共通機能の集約
 *    - Helperクラスによる機能分離
 *    - 設定の外部化による環境対応
 *    - ログ機能の実装余地
 */