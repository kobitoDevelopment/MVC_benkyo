<?php
/**
 * =================================================================
 * Database - シングルトンパターンによるデータベース接続管理クラス
 * =================================================================
 * 
 * 【シングルトンパターンとは】
 * アプリケーション全体でただ1つのインスタンスしか存在しないことを保証する
 * デザインパターンです。データベース接続のようなリソース集約的なオブジェクトに
 * 適用することで、メモリ効率とパフォーマンスを向上させます。
 * 
 * 【このパターンを使う理由】
 * 1. データベース接続の節約（コネクションプールの役割）
 * 2. アプリケーション全体での統一的な設定管理
 * 3. メモリ使用量の最適化
 * 4. 設定の一元管理による保守性向上
 * 
 * 【注意点】
 * - テスタビリティの課題（モッキングが困難）
 * - 依存関係の隠蔽によるコードの結合度上昇
 * - マルチスレッド環境での同期問題
 */

namespace App\Core;

use PDO;
use PDOException;

/**
 * シングルトンパターンによるデータベース接続クラス
 * 
 * 【実装のポイント】
 * 1. コンストラクタをprivateにして外部からのインスタンス生成を防止
 * 2. staticな$instanceプロパティで唯一のインスタンスを保持
 * 3. getInstance()メソッドでインスタンスへのアクセスを提供
 * 4. __clone()と__wakeup()を封じてインスタンスの複製を防止
 */
class Database
{
    /**
     * シングルトンインスタンスを格納する静的プロパティ
     * 
     * 【static変数の特徴】
     * - クラスレベルで共有される（インスタンス間で共通）
     * - プロセス終了まで値を保持
     * - メモリ上に1つだけ存在
     */
    private static $instance = null;
    
    /**
     * PDOデータベース接続オブジェクト
     * 
     * 【PDO（PHP Data Objects）とは】
     * PHPでデータベースにアクセスするための統一インターフェース
     * 複数のデータベース（MySQL, PostgreSQL, SQLiteなど）を
     * 同じAPIで操作できます
     */
    private $connection;
    
    /**
     * プライベートコンストラクタ
     * 
     * 【private修飾子の意図】
     * 外部から new Database() での直接インスタンス生成を禁止
     * これによりシングルトンパターンを強制します
     * 
     * 【初期化処理】
     * 1. 設定ファイルの読み込み
     * 2. DSN（Data Source Name）の構築
     * 3. PDO接続の確立
     * 4. PDO設定の初期化
     */
    private function __construct()
    {
        // 設定ファイルから接続パラメータを読み込み
        $config = require __DIR__ . '/../config/database.php';
        
        try {
            // ============================================================
            // DSN（Data Source Name）の構築
            // ============================================================
            // DSNはデータベース接続に必要な情報をまとめた文字列
            // 形式: "mysql:host=localhost;dbname=myapp;charset=utf8mb4"
            $dsn = "mysql:host={$config['host']};dbname={$config['database']};charset={$config['charset']}";
            
            // ============================================================
            // PDO接続の確立
            // ============================================================
            $this->connection = new PDO(
                $dsn,                    // データソース名
                $config['username'],     // データベースユーザー名
                $config['password']      // パスワード
            );
            
            // ============================================================
            // PDO設定の初期化
            // ============================================================
            
            // エラーモードを例外モードに設定
            // SQLエラーが発生した際にPDOExceptionをスローします
            // これによりエラーハンドリングが簡潔になります
            $this->connection->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
            
            // デフォルトのフェッチモードを連想配列に設定
            // SELECT文の結果をカラム名をキーとした連想配列で取得
            // 例: ['id' => 1, 'name' => 'John'] の形式になります
            $this->connection->setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC);
            
        } catch (PDOException $e) {
            // データベース接続エラーの処理
            // 本番環境では詳細なエラー情報は表示せず、ログに記録することを推奨
            die("Database Connection Error: " . $e->getMessage());
        }
    }
    
    /**
     * シングルトンインスタンスの取得
     * 
     * 【lazy initialization（遅延初期化）】
     * インスタンスが実際に必要になった時点で初期化を行います
     * アプリケーション起動時の処理時間短縮とメモリ使用量削減を実現
     * 
     * 【スレッドセーフの考慮】
     * PHPは基本的にシングルスレッドですが、将来的な拡張性を考慮し
     * インスタンス生成前のnullチェックを実装
     * 
     * @return Database シングルトンインスタンス
     */
    public static function getInstance()
    {
        // まだインスタンスが生成されていない場合のみ新規作成
        if (self::$instance === null) {
            self::$instance = new self();
        }
        
        return self::$instance;
    }
    
    /**
     * PDO接続オブジェクトの取得
     * 
     * 【カプセル化の実践】
     * 内部のPDOオブジェクトへの直接アクセスを提供しつつ、
     * Database クラスの制御下に置くことで適切な抽象化を実現
     * 
     * 【使用例】
     * $db = Database::getInstance();
     * $pdo = $db->getConnection();
     * $stmt = $pdo->prepare("SELECT * FROM users WHERE id = ?");
     * 
     * @return PDO PDOデータベース接続オブジェクト
     */
    public function getConnection()
    {
        return $this->connection;
    }
    
    /**
     * オブジェクトの複製を防止
     * 
     * 【__clone()マジックメソッド】
     * clone キーワードによるオブジェクトの複製を禁止します
     * シングルトンパターンの整合性を保つために必要
     * 
     * 例: $copy = clone Database::getInstance(); // エラーになる
     */
    private function __clone() 
    {
        // 空実装でcloneを無効化
    }
    
    /**
     * シリアライゼーション後の復元を防止
     * 
     * 【__wakeup()マジックメソッド】
     * unserialize()による既存インスタンスの復元を防ぎます
     * シリアライゼーション経由でのシングルトン破綻を防止
     * 
     * 【シリアライゼーションとは】
     * オブジェクトを文字列に変換して保存・転送可能にする機能
     * セッションやキャッシュでよく使われます
     */
    public function __wakeup() 
    {
        // 空実装でunserializeを無効化
    }
}

/**
 * =================================================================
 * 【学習ポイント】シングルトンパターンの実装テクニック
 * =================================================================
 * 
 * 1. 【インスタンス管理の3つの防御策】
 *    - private constructor: 直接インスタンス生成を防止
 *    - private __clone(): オブジェクト複製を防止
 *    - public __wakeup(): シリアライゼーション復元を防止
 * 
 * 2. 【PDO設定のベストプラクティス】
 *    - ERRMODE_EXCEPTION: 例外による統一的エラーハンドリング
 *    - FETCH_ASSOC: 連想配列による直感的なデータ操作
 *    - charset指定: 文字化け防止
 * 
 * 3. 【設定の外部化】
 *    - 機密情報（パスワードなど）の分離
 *    - 環境別設定の切り替え容易性
 *    - バージョン管理での機密情報除外
 * 
 * 4. 【エラーハンドリング】
 *    - try-catch による例外処理
 *    - 適切なエラーメッセージの提供
 *    - セキュリティ考慮（本番環境では詳細情報を隠蔽）
 * 
 * 5. 【代替案の検討】
 *    - 依存性注入コンテナ（DI Container）
 *    - ファクトリーパターン
 *    - リポジトリパターンとの組み合わせ
 */