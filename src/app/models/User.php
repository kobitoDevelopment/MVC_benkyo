<?php
/**
 * =================================================================
 * User Model - MVCアーキテクチャのModel層を担当するクラス
 * =================================================================
 * 
 * 【Model層の役割】
 * MVCパターンにおけるModel層は以下の責任を持ちます：
 * 1. データベースへの直接アクセス
 * 2. ビジネスロジックの実装
 * 3. データの整合性保証
 * 4. セキュリティ対策（SQLインジェクション防止など）
 * 
 * 【Active Recordパターン】
 * このクラスはActive Recordパターンを採用しています。
 * データベースのテーブル（users）とオブジェクト（User）を1対1で対応させ、
 * CRUDオペレーションをオブジェクトのメソッドとして提供します。
 * 
 * 【データアクセス層（DAL）としての機能】
 * - プリペアドステートメントによるSQLインジェクション対策
 * - 型安全なデータバインディング
 * - 結果セットの適切な処理
 */

namespace App\Models;

use App\Core\Database;
use PDO;

/**
 * Userモデルクラス
 * 
 * 【責任範囲】
 * - ユーザー認証に関するデータアクセス
 * - セッション管理のデータベース操作
 * - ユーザー情報のCRUD操作
 * 
 * 【セキュリティ考慮事項】
 * - 全てのSQL文でプリペアドステートメントを使用
 * - パスワードは事前にハッシュ化されている前提
 * - セッションIDとユーザーIDの関連付けを厳密に管理
 */
class User
{
    /**
     * データベース接続オブジェクト
     * 
     * 【PDOオブジェクトの活用】
     * - プリペアドステートメントによるセキュアなSQL実行
     * - 型安全なパラメータバインディング
     * - トランザクション機能（将来の拡張で使用可能）
     */
    private $db;
    
    /**
     * コンストラクタ
     * 
     * 【依存性注入の簡易版】
     * シングルトンパターンのDatabaseクラスから接続を取得
     * 理想的にはコンストラクタで接続オブジェクトを受け取る方が
     * テスタビリティが向上しますが、学習用として簡潔な実装を採用
     */
    public function __construct()
    {
        // シングルトンのDatabaseインスタンスからPDO接続を取得
        $this->db = Database::getInstance()->getConnection();
    }
    
    /**
     * ユーザー名によるユーザー検索
     * 
     * 【認証処理での使用】
     * ログイン時にユーザー名からユーザー情報を取得する際に使用
     * パスワードの検証はこの後に password_verify() で行います
     * 
     * 【セキュリティ対策】
     * 1. プリペアドステートメントでSQLインジェクション対策
     * 2. LIMIT 1で不要な検索コストを削減
     * 3. 名前付きプレースホルダー（:username）で可読性向上
     * 
     * @param string $username 検索するユーザー名
     * @return array|false ユーザー情報の連想配列、見つからない場合はfalse
     */
    public function findByUsername($username)
    {
        // ============================================================
        // プリペアドステートメントの準備
        // ============================================================
        // prepare()により、SQLとデータを分離してセキュリティを確保
        $stmt = $this->db->prepare("SELECT * FROM users WHERE username = :username LIMIT 1");
        
        // ============================================================
        // パラメータバインディングと実行
        // ============================================================
        // 連想配列でプレースホルダーに値を安全にバインド
        $stmt->execute(['username' => $username]);
        
        // ============================================================
        // 結果の取得
        // ============================================================
        // fetch()は1行のみ取得、見つからない場合はfalseを返す
        return $stmt->fetch();
    }
    
    /**
     * ユーザーIDによるユーザー検索
     * 
     * 【セッション復元時の使用】
     * セッションに保存されたuser_idから最新のユーザー情報を取得
     * ユーザー情報の変更（名前変更など）がセッション中に反映される
     * 
     * 【プライマリキー検索の特徴】
     * - インデックスが効くため高速
     * - 一意性が保証されている
     * - キャッシュ効果が期待できる
     * 
     * @param int $id 検索するユーザーID
     * @return array|false ユーザー情報の連想配列、見つからない場合はfalse
     */
    public function findById($id)
    {
        $stmt = $this->db->prepare("SELECT * FROM users WHERE id = :id LIMIT 1");
        $stmt->execute(['id' => $id]);
        return $stmt->fetch();
    }
    
    /**
     * セッション情報のデータベース保存・更新
     * 
     * 【セッションのデータベース管理の利点】
     * 1. セッションハイジャック対策の強化
     * 2. 複数サーバー間でのセッション共有
     * 3. セッションの詳細な監査ログ
     * 4. 異常アクセスの早期発見
     * 
     * 【ON DUPLICATE KEY UPDATEの活用】
     * 同一セッションIDに対しては更新、新規の場合は挿入
     * これによりアプリケーションコードでのIF文が不要になり
     * データベースレベルでの原子性が保証されます
     * 
     * @param int $user_id ユーザーID
     * @param string $session_id セッションID
     */
    public function createSession($user_id, $session_id)
    {
        // ============================================================
        // UPSERT（INSERT or UPDATE）クエリの実行
        // ============================================================
        $stmt = $this->db->prepare("
            INSERT INTO sessions (id, user_id, ip_address, user_agent, last_activity) 
            VALUES (:session_id, :user_id, :ip, :agent, :time)
            ON DUPLICATE KEY UPDATE 
                user_id = :user_id,
                ip_address = :ip,
                user_agent = :agent,
                last_activity = :time
        ");
        
        // ============================================================
        // セキュリティ情報の収集と保存
        // ============================================================
        $stmt->execute([
            'session_id' => $session_id,
            'user_id' => $user_id,
            
            // IPアドレスの取得（プロキシ経由も考慮）
            // ?? 演算子で値が無い場合のデフォルト値を設定
            'ip' => $_SERVER['REMOTE_ADDR'] ?? '',
            
            // ブラウザ情報の取得（フィンガープリンティング用）
            'agent' => $_SERVER['HTTP_USER_AGENT'] ?? '',
            
            // UNIXタイムスタンプでの活動時刻記録
            'time' => time()
        ]);
    }
    
    /**
     * セッション情報の削除（ログアウト処理）
     * 
     * 【安全なログアウトの実装】
     * 1. データベースからセッション情報を削除
     * 2. PHPセッションの破棄（LoginController側で実装）
     * 3. セッションクッキーの削除
     * 
     * 【なりすまし防止】
     * セッションIDを知っている第三者がいても、
     * データベース上の情報が削除されるため再認証が必要になります
     * 
     * @param string $session_id 削除するセッションID
     */
    public function deleteSession($session_id)
    {
        $stmt = $this->db->prepare("DELETE FROM sessions WHERE id = :session_id");
        $stmt->execute(['session_id' => $session_id]);
    }
}

/**
 * =================================================================
 * 【学習ポイント】Modelクラスの設計原則とベストプラクティス
 * =================================================================
 * 
 * 1. 【単一責任の原則（SRP）】
 *    - Userモデルはユーザーに関連するデータ操作のみを担当
 *    - ビュー表示やHTTPリクエスト処理は含まない
 *    - ビジネスロジックとデータアクセスの適切な分離
 * 
 * 2. 【データアクセスのセキュリティ】
 *    - 全SQL文でプリペアドステートメントを使用
 *    - 適切なLIMIT句での性能向上とリソース保護
 *    - 型安全なパラメータバインディング
 * 
 * 3. 【エラーハンドリングの考慮】
 *    - PDO例外の適切な処理（Database.phpで設定済み）
 *    - falseの返却による明確な失敗通知
 *    - ログ出力による問題の追跡可能性
 * 
 * 4. 【拡張性の確保】
 *    - 新しいメソッド追加の容易性
 *    - リポジトリパターンへの移行可能性
 *    - ORMライブラリとの互換性
 * 
 * 5. 【パフォーマンス考慮】
 *    - 必要最小限のデータ取得
 *    - インデックスを活用したクエリ設計
 *    - N+1問題の回避（将来の拡張で重要）
 */